RELATÓRIO DE COMPILAÇÃO - LINGUAGEM GOIANINHA
Data de execução: Dom  7 Dez 2025 20:11:01 -03
============================================================

############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/SeqOrdenada.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável quant redeclarada na linha 31
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str4: .asciiz ""DESORDENADA""
_str3: .asciiz ""ORDENADA""
_str2: .asciiz ""digite o tamanho de uma sequencia de numeros inteiros - digite 0 para terminar.""
_str1: .asciiz "" numeros inteiros separados entre si por um espaco""
_str0: .asciiz ""digite uma sequencia de ""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


checaOrd:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    li $t0, 118
    sw $t0, -4($fp)
    li $t0, 1
    sw $t0, -4($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_0:
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_1

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    lw $t0, -4($fp)
    sw $t0, -4($fp)
    j _L_endif_3
_L_else_2:
    li $t1, 102
    sw $t1, -4($fp)
    lw $t1, -4($fp)
    sw $t1, -4($fp)
_L_endif_3:
    lw $t1, -4($fp)
    li $t2, 1
    add $t1, $t1, $t2
    sw $t1, -4($fp)
    lw $t2, -4($fp)
    lw $t3, -4($fp)
    slt $t2, $t2, $t3
    beq $t2, $zero, _L_else_4
    lw $t2, -4($fp)
    sw $t2, -4($fp)
    j _L_endif_5
_L_else_4:
    li $t3, 102
    sw $t3, -4($fp)
    lw $t3, -4($fp)
    sw $t3, -4($fp)
_L_endif_5:
    lw $t3, -4($fp)
    li $t4, 1
    add $t3, $t3, $t4
    sw $t3, -4($fp)
    lw $t4, -4($fp)
    li $t5, 1
    add $t4, $t4, $t5
    sw $t4, -4($fp)
    j _L_startwhile_0
_L_endwhile_1:
    lw $t4, -4($fp)
    move $v0, $t4
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $v0, 4
    syscall
    lw $t4, -4($fp)

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_6:
    lw $t4, -4($fp)
    lw $t5, -4($fp)
    slt $t4, $t4, $t5
    beq $t4, $zero, _L_endwhile_7

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t4, -4($fp)
    lw $t5, -4($fp)
    slt $t4, $t4, $t5
    beq $t4, $zero, _L_else_8
    lw $t4, -4($fp)
    sw $t4, -4($fp)
    j _L_endif_9
_L_else_8:
    li $t5, 102
    sw $t5, -4($fp)
    lw $t5, -4($fp)
    sw $t5, -4($fp)
_L_endif_9:
    lw $t5, -4($fp)
    li $t6, 1
    add $t5, $t5, $t6
    sw $t5, -4($fp)
    lw $t6, -4($fp)
    lw $t7, -4($fp)
    slt $t6, $t6, $t7
    beq $t6, $zero, _L_else_10
    lw $t6, -4($fp)
    sw $t6, -4($fp)
    j _L_endif_11
_L_else_10:
    li $t7, 102
    sw $t7, -4($fp)
    lw $t7, -4($fp)
    sw $t7, -4($fp)
_L_endif_11:
    lw $t7, -4($fp)
    li $t8, 1
    add $t7, $t7, $t8
    sw $t7, -4($fp)
    lw $t8, -4($fp)
    li $t9, 1
    add $t8, $t8, $t9
    sw $t8, -4($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t8, -4($fp)
    move $v0, $t8
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $t8, -4($fp)

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_12:
    lw $t8, -4($fp)
    lw $t9, -4($fp)
    slt $t8, $t8, $t9
    beq $t8, $zero, _L_endwhile_13

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t8, -4($fp)
    lw $t9, -4($fp)
    slt $t8, $t8, $t9
    beq $t8, $zero, _L_else_14
    lw $t8, -4($fp)
    sw $t8, -4($fp)
    j _L_endif_15
_L_else_14:
    li $t9, 102
    sw $t9, -4($fp)
    lw $t9, -4($fp)
    sw $t9, -4($fp)
_L_endif_15:
    lw $t9, -4($fp)


############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/FibEfatCorretoVersao2.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável somaFunc redeclarada na linha 27
ERRO: Variável n redeclarada na linha 29
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    sw $t0, -4($fp)
    lw $t0, -4($fp)
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/expressao1Correto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
BLOCK (Linha: 8)
  DECLARAÇÕES:
    VAR_DECL (Nome: x, Tipo: int, Linha: 4)
    VAR_DECL (Nome: y, Tipo: int, Linha: 3)
    VAR_DECL (Nome: z, Tipo: int, Linha: 3)
    VAR_DECL (Nome: v, Tipo: int, Linha: 3)
  COMANDOS:
    ASSIGN (Linha: 4)
      ID (Nome: z, Linha: 4)
      ASSIGN (Linha: 4)
        ID (Nome: y, Linha: 4)
        ASSIGN (Linha: 4)
          ID (Nome: x, Linha: 4)
          INTCONST (Valor: 50, Linha: 4)
    WRITE (Linha: 5)
      ID (Nome: x, Linha: 5)
    STRINGCONST (Valor: "" "", Linha: 5)
    WRITE (Linha: 5)
      ID (Nome: y, Linha: 5)
    STRINGCONST (Valor: "" "", Linha: 5)
    WRITE (Linha: 5)
      ID (Nome: z, Linha: 5)
    NOVALINHA (Linha: 6)
    WRITE (Linha: 7)
      OP_BIN (Op: 1, Linha: 7)
        OP_BIN (Op: 2, Linha: 7)
          ID (Nome: x, Linha: 7)
          INTCONST (Valor: 2, Linha: 7)
        OP_BIN (Op: 3, Linha: 7)
          ID (Nome: y, Linha: 7)
          INTCONST (Valor: 4, Linha: 7)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str0: .asciiz "" ""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 4
    move $fp, $sp

    li $t0, 50
    sw $t0, -4($fp)
    sw $t0, -4($fp)
    sw $t0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 4
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/FibEfatCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 30
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/variaveisGlobaisVariaveisFuncoesCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável x redeclarada na linha 8
ERRO: Variável x redeclarada na linha 10
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
VAR_DECL (Nome: x, Tipo: int, Linha: 8)
FUNC_DEF (Nome: duplicado, Tipo Retorno: int, Linha: 6)
  PARAMS:
    VAR_DECL (Nome: x, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 6)
      COMANDOS:
        WRITE (Linha: 4)
          ID (Nome: x, Linha: 4)
        RETURN (Linha: 5)
          INTCONST (Valor: 0, Linha: 5)
BLOCK (Linha: 12)
  DECLARAÇÕES:
    VAR_DECL (Nome: x, Tipo: int, Linha: 10)
  COMANDOS:
    ASSIGN (Linha: 10)
      ID (Nome: x, Linha: 10)
      INTCONST (Valor: 2, Linha: 10)
    FUNCCALL (Linha: 11)
      ID (Nome: duplicado, Linha: 11)
      ARGS:
        ID (Nome: x, Linha: 11)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
x: .word 0

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


duplicado:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 2
    sw $t0, -4($fp)
    lw $t1, -4($fp)
    move $a0, $t1
    jal duplicado
    move $t0, $v0

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/NotaEmConceito.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável conceito redeclarada na linha 11
ERRO: Variável conceito redeclarada na linha 20
ERRO: Variável conceito redeclarada na linha 29
ERRO: Variável conceito redeclarada na linha 36
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
BLOCK (Linha: 44)
  DECLARAÇÕES:
    VAR_DECL (Nome: nota, Tipo: int, Linha: 4)
    VAR_DECL (Nome: conceito, Tipo: car, Linha: 4)
  COMANDOS:
    STRINGCONST (Valor: ""Digite um valor inteiro para a nota de um aluno"", Linha: 4)
    NOVALINHA (Linha: 5)
    READ (Linha: 6)
      ID (Nome: nota, Linha: 6)
    IF (Linha: 42)
      OP_BIN (Op: 6, Linha: 8)
        ID (Nome: nota, Linha: 8)
        INTCONST (Valor: 6, Linha: 8)
      BLOCK (Linha: 15)
        DECLARAÇÕES:
          VAR_DECL (Nome: conceito, Tipo: car, Linha: 11)
        COMANDOS:
          ASSIGN (Linha: 11)
            ID (Nome: conceito, Linha: 11)
            CHARCONST (Valor: 'D', Linha: 11)
          STRINGCONST (Valor: ""Conceito: "", Linha: 12)
          WRITE (Linha: 13)
            ID (Nome: conceito, Linha: 13)
          NOVALINHA (Linha: 14)
    ELSE
      BLOCK (Linha: 42)
        COMANDOS:
          IF (Linha: 41)
            OP_BIN (Op: 6, Linha: 17)
              ID (Nome: nota, Linha: 17)
              INTCONST (Valor: 7, Linha: 17)
            BLOCK (Linha: 24)
              DECLARAÇÕES:
                VAR_DECL (Nome: conceito, Tipo: car, Linha: 20)
              COMANDOS:
                ASSIGN (Linha: 20)
                  ID (Nome: conceito, Linha: 20)
                  CHARCONST (Valor: 'C', Linha: 20)
                STRINGCONST (Valor: ""Conceito: "", Linha: 21)
                WRITE (Linha: 22)
                  ID (Nome: conceito, Linha: 22)
                NOVALINHA (Linha: 23)
          ELSE
            BLOCK (Linha: 41)
              COMANDOS:
                IF (Linha: 40)
                  OP_BIN (Op: 6, Linha: 26)
                    ID (Nome: nota, Linha: 26)
                    INTCONST (Valor: 9, Linha: 26)
                  BLOCK (Linha: 33)
                    DECLARAÇÕES:
                      VAR_DECL (Nome: conceito, Tipo: car, Linha: 29)
                    COMANDOS:
                      ASSIGN (Linha: 29)
                        ID (Nome: conceito, Linha: 29)
                        CHARCONST (Valor: 'B', Linha: 29)
                      STRINGCONST (Valor: ""Conceito: "", Linha: 30)
                      WRITE (Linha: 31)
                        ID (Nome: conceito, Linha: 31)
                      NOVALINHA (Linha: 32)
                ELSE
                  BLOCK (Linha: 40)
                    DECLARAÇÕES:
                      VAR_DECL (Nome: conceito, Tipo: car, Linha: 36)
                    COMANDOS:
                      ASSIGN (Linha: 36)
                        ID (Nome: conceito, Linha: 36)
                        CHARCONST (Valor: 'A', Linha: 36)
                      STRINGCONST (Valor: ""Conceito: "", Linha: 37)
                      WRITE (Linha: 38)
                        ID (Nome: conceito, Linha: 38)
                      NOVALINHA (Linha: 39)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str1: .asciiz ""Conceito: ""
_str0: .asciiz ""Digite um valor inteiro para a nota de um aluno""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 8
    move $fp, $sp

    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_5
_L_else_4:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_5:
_L_endif_3:
_L_endif_1:

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_6
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_7
_L_else_6:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_8
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_9
_L_else_8:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_10
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_11
_L_else_10:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_11:
_L_endif_9:
_L_endif_7:

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_12
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_13
_L_else_12:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_14
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_15
_L_else_14:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_16
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_17
_L_else_16:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_17:
_L_endif_15:
_L_endif_13:
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_18
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_19
_L_else_18:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_20
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_21
_L_else_20:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_22
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_23
_L_else_22:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_23:
_L_endif_21:
_L_endif_19:

    # Limpeza do Stack Frame
    addu $sp, $sp, 8
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./geracaoCodigo/Corretos/fatorialCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 12
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: fatorial, Tipo Retorno: int, Linha: 8)
  PARAMS:
    VAR_DECL (Nome: n, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 8)
      COMANDOS:
        IF (Linha: 7)
          OP_BIN (Op: 4, Linha: 3)
            ID (Nome: n, Linha: 3)
            INTCONST (Valor: 0, Linha: 3)
          RETURN (Linha: 5)
            INTCONST (Valor: 1, Linha: 5)
        ELSE
          RETURN (Linha: 7)
            OP_BIN (Op: 2, Linha: 7)
              ID (Nome: n, Linha: 7)
              FUNCCALL (Linha: 7)
                ID (Nome: fatorial, Linha: 7)
                ARGS:
                  OP_BIN (Op: 1, Linha: 7)
                    ID (Nome: n, Linha: 7)
                    INTCONST (Valor: 1, Linha: 7)
BLOCK (Linha: 23)
  DECLARAÇÕES:
    VAR_DECL (Nome: n, Tipo: int, Linha: 12)
  COMANDOS:
    ASSIGN (Linha: 12)
      ID (Nome: n, Linha: 12)
      INTCONST (Valor: 1, Linha: 12)
    WHILE (Linha: 17)
      OP_BIN (Op: 8, Linha: 13)
        ID (Nome: n, Linha: 13)
        INTCONST (Valor: 0, Linha: 13)
      BLOCK (Linha: 17)
        COMANDOS:
          STRINGCONST (Valor: ""digite um numero"", Linha: 14)
          NOVALINHA (Linha: 15)
          READ (Linha: 16)
            ID (Nome: n, Linha: 16)
    STRINGCONST (Valor: ""O fatorial de "", Linha: 18)
    WRITE (Linha: 19)
      ID (Nome: n, Linha: 19)
    STRINGCONST (Valor: "" e: "", Linha: 20)
    WRITE (Linha: 21)
      FUNCCALL (Linha: 21)
        ID (Nome: fatorial, Linha: 21)
        ARGS:
          ID (Nome: n, Linha: 21)
    NOVALINHA (Linha: 22)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    sw $t0, -4($fp)
_L_startwhile_2:
    lw $t0, -4($fp)
    li $t1, 0
    sgt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_3
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_2
_L_endwhile_3:
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Corretos/SeqOrdenada.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável quant redeclarada na linha 31
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str4: .asciiz ""DESORDENADA""
_str3: .asciiz ""ORDENADA""
_str2: .asciiz ""digite o tamanho de uma sequencia de numeros inteiros - digite 0 para terminar.""
_str1: .asciiz "" numeros inteiros separados entre si por um espaco""
_str0: .asciiz ""digite uma sequencia de ""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


checaOrd:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    li $t0, 118
    sw $t0, -4($fp)
    li $t0, 1
    sw $t0, -4($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_0:
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_1

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    lw $t0, -4($fp)
    sw $t0, -4($fp)
    j _L_endif_3
_L_else_2:
    li $t1, 102
    sw $t1, -4($fp)
    lw $t1, -4($fp)
    sw $t1, -4($fp)
_L_endif_3:
    lw $t1, -4($fp)
    li $t2, 1
    add $t1, $t1, $t2
    sw $t1, -4($fp)
    lw $t2, -4($fp)
    lw $t3, -4($fp)
    slt $t2, $t2, $t3
    beq $t2, $zero, _L_else_4
    lw $t2, -4($fp)
    sw $t2, -4($fp)
    j _L_endif_5
_L_else_4:
    li $t3, 102
    sw $t3, -4($fp)
    lw $t3, -4($fp)
    sw $t3, -4($fp)
_L_endif_5:
    lw $t3, -4($fp)
    li $t4, 1
    add $t3, $t3, $t4
    sw $t3, -4($fp)
    lw $t4, -4($fp)
    li $t5, 1
    add $t4, $t4, $t5
    sw $t4, -4($fp)
    j _L_startwhile_0
_L_endwhile_1:
    lw $t4, -4($fp)
    move $v0, $t4
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $v0, 4
    syscall
    lw $t4, -4($fp)

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_6:
    lw $t4, -4($fp)
    lw $t5, -4($fp)
    slt $t4, $t4, $t5
    beq $t4, $zero, _L_endwhile_7

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t4, -4($fp)
    lw $t5, -4($fp)
    slt $t4, $t4, $t5
    beq $t4, $zero, _L_else_8
    lw $t4, -4($fp)
    sw $t4, -4($fp)
    j _L_endif_9
_L_else_8:
    li $t5, 102
    sw $t5, -4($fp)
    lw $t5, -4($fp)
    sw $t5, -4($fp)
_L_endif_9:
    lw $t5, -4($fp)
    li $t6, 1
    add $t5, $t5, $t6
    sw $t5, -4($fp)
    lw $t6, -4($fp)
    lw $t7, -4($fp)
    slt $t6, $t6, $t7
    beq $t6, $zero, _L_else_10
    lw $t6, -4($fp)
    sw $t6, -4($fp)
    j _L_endif_11
_L_else_10:
    li $t7, 102
    sw $t7, -4($fp)
    lw $t7, -4($fp)
    sw $t7, -4($fp)
_L_endif_11:
    lw $t7, -4($fp)
    li $t8, 1
    add $t7, $t7, $t8
    sw $t7, -4($fp)
    lw $t8, -4($fp)
    li $t9, 1
    add $t8, $t8, $t9
    sw $t8, -4($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t8, -4($fp)
    move $v0, $t8
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $t8, -4($fp)

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_12:
    lw $t8, -4($fp)
    lw $t9, -4($fp)
    slt $t8, $t8, $t9
    beq $t8, $zero, _L_endwhile_13

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t8, -4($fp)
    lw $t9, -4($fp)
    slt $t8, $t8, $t9
    beq $t8, $zero, _L_else_14
    lw $t8, -4($fp)
    sw $t8, -4($fp)
    j _L_endif_15
_L_else_14:
    li $t9, 102
    sw $t9, -4($fp)
    lw $t9, -4($fp)
    sw $t9, -4($fp)
_L_endif_15:
    lw $t9, -4($fp)


############################################################
ARQUIVO FONTE: ./semantico/Corretos/FibEfatCorretoVersao2.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável somaFunc redeclarada na linha 27
ERRO: Variável n redeclarada na linha 29
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    sw $t0, -4($fp)
    lw $t0, -4($fp)
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./semantico/Corretos/expressao1Correto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
BLOCK (Linha: 8)
  DECLARAÇÕES:
    VAR_DECL (Nome: x, Tipo: int, Linha: 4)
    VAR_DECL (Nome: y, Tipo: int, Linha: 3)
    VAR_DECL (Nome: z, Tipo: int, Linha: 3)
    VAR_DECL (Nome: v, Tipo: int, Linha: 3)
  COMANDOS:
    ASSIGN (Linha: 4)
      ID (Nome: z, Linha: 4)
      ASSIGN (Linha: 4)
        ID (Nome: y, Linha: 4)
        ASSIGN (Linha: 4)
          ID (Nome: x, Linha: 4)
          INTCONST (Valor: 50, Linha: 4)
    WRITE (Linha: 5)
      ID (Nome: x, Linha: 5)
    STRINGCONST (Valor: "" "", Linha: 5)
    WRITE (Linha: 5)
      ID (Nome: y, Linha: 5)
    STRINGCONST (Valor: "" "", Linha: 5)
    WRITE (Linha: 5)
      ID (Nome: z, Linha: 5)
    NOVALINHA (Linha: 6)
    WRITE (Linha: 7)
      OP_BIN (Op: 1, Linha: 7)
        OP_BIN (Op: 2, Linha: 7)
          ID (Nome: x, Linha: 7)
          INTCONST (Valor: 2, Linha: 7)
        OP_BIN (Op: 3, Linha: 7)
          ID (Nome: y, Linha: 7)
          INTCONST (Valor: 4, Linha: 7)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str0: .asciiz "" ""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 4
    move $fp, $sp

    li $t0, 50
    sw $t0, -4($fp)
    sw $t0, -4($fp)
    sw $t0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 4
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Corretos/FibEfatCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 30
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./semantico/Corretos/variaveisGlobaisVariaveisFuncoesCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável x redeclarada na linha 8
ERRO: Variável x redeclarada na linha 10
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
VAR_DECL (Nome: x, Tipo: int, Linha: 8)
FUNC_DEF (Nome: duplicado, Tipo Retorno: int, Linha: 6)
  PARAMS:
    VAR_DECL (Nome: x, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 6)
      COMANDOS:
        WRITE (Linha: 4)
          ID (Nome: x, Linha: 4)
        RETURN (Linha: 5)
          INTCONST (Valor: 0, Linha: 5)
BLOCK (Linha: 12)
  DECLARAÇÕES:
    VAR_DECL (Nome: x, Tipo: int, Linha: 10)
  COMANDOS:
    ASSIGN (Linha: 10)
      ID (Nome: x, Linha: 10)
      INTCONST (Valor: 2, Linha: 10)
    FUNCCALL (Linha: 11)
      ID (Nome: duplicado, Linha: 11)
      ARGS:
        ID (Nome: x, Linha: 11)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
x: .word 0

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


duplicado:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 2
    sw $t0, -4($fp)
    lw $t1, -4($fp)
    move $a0, $t1
    jal duplicado
    move $t0, $v0

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Corretos/NotaEmConceito.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável conceito redeclarada na linha 11
ERRO: Variável conceito redeclarada na linha 20
ERRO: Variável conceito redeclarada na linha 29
ERRO: Variável conceito redeclarada na linha 36
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
BLOCK (Linha: 44)
  DECLARAÇÕES:
    VAR_DECL (Nome: nota, Tipo: int, Linha: 4)
    VAR_DECL (Nome: conceito, Tipo: car, Linha: 4)
  COMANDOS:
    STRINGCONST (Valor: ""Digite um valor inteiro para a nota de um aluno"", Linha: 4)
    NOVALINHA (Linha: 5)
    READ (Linha: 6)
      ID (Nome: nota, Linha: 6)
    IF (Linha: 42)
      OP_BIN (Op: 6, Linha: 8)
        ID (Nome: nota, Linha: 8)
        INTCONST (Valor: 6, Linha: 8)
      BLOCK (Linha: 15)
        DECLARAÇÕES:
          VAR_DECL (Nome: conceito, Tipo: car, Linha: 11)
        COMANDOS:
          ASSIGN (Linha: 11)
            ID (Nome: conceito, Linha: 11)
            CHARCONST (Valor: 'D', Linha: 11)
          STRINGCONST (Valor: ""Conceito: "", Linha: 12)
          WRITE (Linha: 13)
            ID (Nome: conceito, Linha: 13)
          NOVALINHA (Linha: 14)
    ELSE
      BLOCK (Linha: 42)
        COMANDOS:
          IF (Linha: 41)
            OP_BIN (Op: 6, Linha: 17)
              ID (Nome: nota, Linha: 17)
              INTCONST (Valor: 7, Linha: 17)
            BLOCK (Linha: 24)
              DECLARAÇÕES:
                VAR_DECL (Nome: conceito, Tipo: car, Linha: 20)
              COMANDOS:
                ASSIGN (Linha: 20)
                  ID (Nome: conceito, Linha: 20)
                  CHARCONST (Valor: 'C', Linha: 20)
                STRINGCONST (Valor: ""Conceito: "", Linha: 21)
                WRITE (Linha: 22)
                  ID (Nome: conceito, Linha: 22)
                NOVALINHA (Linha: 23)
          ELSE
            BLOCK (Linha: 41)
              COMANDOS:
                IF (Linha: 40)
                  OP_BIN (Op: 6, Linha: 26)
                    ID (Nome: nota, Linha: 26)
                    INTCONST (Valor: 9, Linha: 26)
                  BLOCK (Linha: 33)
                    DECLARAÇÕES:
                      VAR_DECL (Nome: conceito, Tipo: car, Linha: 29)
                    COMANDOS:
                      ASSIGN (Linha: 29)
                        ID (Nome: conceito, Linha: 29)
                        CHARCONST (Valor: 'B', Linha: 29)
                      STRINGCONST (Valor: ""Conceito: "", Linha: 30)
                      WRITE (Linha: 31)
                        ID (Nome: conceito, Linha: 31)
                      NOVALINHA (Linha: 32)
                ELSE
                  BLOCK (Linha: 40)
                    DECLARAÇÕES:
                      VAR_DECL (Nome: conceito, Tipo: car, Linha: 36)
                    COMANDOS:
                      ASSIGN (Linha: 36)
                        ID (Nome: conceito, Linha: 36)
                        CHARCONST (Valor: 'A', Linha: 36)
                      STRINGCONST (Valor: ""Conceito: "", Linha: 37)
                      WRITE (Linha: 38)
                        ID (Nome: conceito, Linha: 38)
                      NOVALINHA (Linha: 39)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str1: .asciiz ""Conceito: ""
_str0: .asciiz ""Digite um valor inteiro para a nota de um aluno""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 8
    move $fp, $sp

    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_5
_L_else_4:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_5:
_L_endif_3:
_L_endif_1:

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_6
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_7
_L_else_6:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_8
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_9
_L_else_8:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_10
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_11
_L_else_10:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_11:
_L_endif_9:
_L_endif_7:

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_12
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_13
_L_else_12:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_14
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_15
_L_else_14:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_16
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_17
_L_else_16:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_17:
_L_endif_15:
_L_endif_13:
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_18
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_19
_L_else_18:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_20
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_21
_L_else_20:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_22
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_23
_L_else_22:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_23:
_L_endif_21:
_L_endif_19:

    # Limpeza do Stack Frame
    addu $sp, $sp, 8
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Corretos/fatorialCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 12
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: fatorial, Tipo Retorno: int, Linha: 8)
  PARAMS:
    VAR_DECL (Nome: n, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 8)
      COMANDOS:
        IF (Linha: 7)
          OP_BIN (Op: 4, Linha: 3)
            ID (Nome: n, Linha: 3)
            INTCONST (Valor: 0, Linha: 3)
          RETURN (Linha: 5)
            INTCONST (Valor: 1, Linha: 5)
        ELSE
          RETURN (Linha: 7)
            OP_BIN (Op: 2, Linha: 7)
              ID (Nome: n, Linha: 7)
              FUNCCALL (Linha: 7)
                ID (Nome: fatorial, Linha: 7)
                ARGS:
                  OP_BIN (Op: 1, Linha: 7)
                    ID (Nome: n, Linha: 7)
                    INTCONST (Valor: 1, Linha: 7)
BLOCK (Linha: 23)
  DECLARAÇÕES:
    VAR_DECL (Nome: n, Tipo: int, Linha: 12)
  COMANDOS:
    ASSIGN (Linha: 12)
      ID (Nome: n, Linha: 12)
      INTCONST (Valor: 1, Linha: 12)
    WHILE (Linha: 17)
      OP_BIN (Op: 8, Linha: 13)
        ID (Nome: n, Linha: 13)
        INTCONST (Valor: 0, Linha: 13)
      BLOCK (Linha: 17)
        COMANDOS:
          STRINGCONST (Valor: ""digite um numero"", Linha: 14)
          NOVALINHA (Linha: 15)
          READ (Linha: 16)
            ID (Nome: n, Linha: 16)
    STRINGCONST (Valor: ""O fatorial de "", Linha: 18)
    WRITE (Linha: 19)
      ID (Nome: n, Linha: 19)
    STRINGCONST (Valor: "" e: "", Linha: 20)
    WRITE (Linha: 21)
      FUNCCALL (Linha: 21)
        ID (Nome: fatorial, Linha: 21)
        ARGS:
          ID (Nome: n, Linha: 21)
    NOVALINHA (Linha: 22)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    sw $t0, -4($fp)
_L_startwhile_2:
    lw $t0, -4($fp)
    li $t1, 0
    sgt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_3
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_2
_L_endwhile_3:
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Errados/fatorialErroLin5TipoRetornado.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 12
ERRO SEMÂNTICO: Operação aritmética na linha 7 exige operandos do tipo int.
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: fatorial, Tipo Retorno: car, Linha: 8)
  PARAMS:
    VAR_DECL (Nome: n, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 8)
      COMANDOS:
        IF (Linha: 7)
          OP_BIN (Op: 4, Linha: 3)
            ID (Nome: n, Linha: 3)
            INTCONST (Valor: 0, Linha: 3)
          RETURN (Linha: 5)
            INTCONST (Valor: 1, Linha: 5)
        ELSE
          RETURN (Linha: 7)
            OP_BIN (Op: 2, Linha: 7)
              ID (Nome: n, Linha: 7)
              FUNCCALL (Linha: 7)
                ID (Nome: fatorial, Linha: 7)
                ARGS:
                  OP_BIN (Op: 1, Linha: 7)
                    ID (Nome: n, Linha: 7)
                    INTCONST (Valor: 1, Linha: 7)
BLOCK (Linha: 23)
  DECLARAÇÕES:
    VAR_DECL (Nome: n, Tipo: int, Linha: 12)
  COMANDOS:
    ASSIGN (Linha: 12)
      ID (Nome: n, Linha: 12)
      OP_BIN (Op: 1, Linha: 12)
        INTCONST (Valor: 1, Linha: 12)
        INTCONST (Valor: 0, Linha: 12)
    WHILE (Linha: 17)
      OP_BIN (Op: 8, Linha: 13)
        ID (Nome: n, Linha: 13)
        INTCONST (Valor: 0, Linha: 13)
      BLOCK (Linha: 17)
        COMANDOS:
          STRINGCONST (Valor: ""digite um numero"", Linha: 14)
          NOVALINHA (Linha: 15)
          READ (Linha: 16)
            ID (Nome: n, Linha: 16)
    STRINGCONST (Valor: ""O fatorial de "", Linha: 18)
    WRITE (Linha: 19)
      ID (Nome: n, Linha: 19)
    STRINGCONST (Valor: "" e: "", Linha: 20)
    WRITE (Linha: 21)
      FUNCCALL (Linha: 21)
        ID (Nome: fatorial, Linha: 21)
        ARGS:
          ID (Nome: n, Linha: 21)
    NOVALINHA (Linha: 22)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_2:
    lw $t0, -4($fp)
    li $t1, 0
    sgt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_3
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_2
_L_endwhile_3:
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Errados/FibEfatErroCarEIntNaEprLin8.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 30
ERRO SEMÂNTICO: Operação aritmética na linha 9 exige operandos do tipo int.
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    li $t0, 110
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./semantico/Errados/fatorialErroLin3NomeDeclaradoNoMesmoEscopo.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 4
ERRO: Variável n redeclarada na linha 13
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: fatorial, Tipo Retorno: int, Linha: 9)
  PARAMS:
    VAR_DECL (Nome: n, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 9)
      DECLARAÇÕES:
        VAR_DECL (Nome: n, Tipo: int, Linha: 4)
      COMANDOS:
        IF (Linha: 8)
          OP_BIN (Op: 4, Linha: 4)
            ID (Nome: n, Linha: 4)
            INTCONST (Valor: 0, Linha: 4)
          RETURN (Linha: 6)
            INTCONST (Valor: 1, Linha: 6)
        ELSE
          RETURN (Linha: 8)
            OP_BIN (Op: 2, Linha: 8)
              ID (Nome: n, Linha: 8)
              FUNCCALL (Linha: 8)
                ID (Nome: fatorial, Linha: 8)
                ARGS:
                  OP_BIN (Op: 1, Linha: 8)
                    ID (Nome: n, Linha: 8)
                    INTCONST (Valor: 1, Linha: 8)
BLOCK (Linha: 24)
  DECLARAÇÕES:
    VAR_DECL (Nome: n, Tipo: int, Linha: 13)
  COMANDOS:
    ASSIGN (Linha: 13)
      ID (Nome: n, Linha: 13)
      OP_BIN (Op: 1, Linha: 13)
        INTCONST (Valor: 1, Linha: 13)
        INTCONST (Valor: 0, Linha: 13)
    WHILE (Linha: 18)
      OP_BIN (Op: 8, Linha: 14)
        ID (Nome: n, Linha: 14)
        INTCONST (Valor: 0, Linha: 14)
      BLOCK (Linha: 18)
        COMANDOS:
          STRINGCONST (Valor: ""digite um numero"", Linha: 15)
          NOVALINHA (Linha: 16)
          READ (Linha: 17)
            ID (Nome: n, Linha: 17)
    STRINGCONST (Valor: ""O fatorial de "", Linha: 19)
    WRITE (Linha: 20)
      ID (Nome: n, Linha: 20)
    STRINGCONST (Valor: "" e: "", Linha: 21)
    WRITE (Linha: 22)
      FUNCCALL (Linha: 22)
        ID (Nome: fatorial, Linha: 22)
        ARGS:
          ID (Nome: n, Linha: 22)
    NOVALINHA (Linha: 23)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_2:
    lw $t0, -4($fp)
    li $t1, 0
    sgt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_3
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_2
_L_endwhile_3:
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Errados/FibEfatErroTIposDiferentesExpEnquntoLin30.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 29
ERRO SEMÂNTICO: Operação relacional na linha 30 exige operandos do mesmo tipo.
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 48
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./semantico/Errados/FuncSomaErroParamDeChamaaDifDoParamFormalLin10.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: soma, Tipo Retorno: int, Linha: 3)
  PARAMS:
    VAR_DECL (Nome: a, Tipo: int, Linha: 1)
    VAR_DECL (Nome: b, Tipo: int, Linha: 1)
  CORPO:
    BLOCK (Linha: 3)
      COMANDOS:
        RETURN (Linha: 2)
          OP_BIN (Op: 0, Linha: 2)
            ID (Nome: a, Linha: 2)
            ID (Nome: b, Linha: 2)
BLOCK (Linha: 14)
  DECLARAÇÕES:
    VAR_DECL (Nome: resultado, Tipo: int, Linha: 8)
    VAR_DECL (Nome: c, Tipo: car, Linha: 8)
  COMANDOS:
    ASSIGN (Linha: 8)
      ID (Nome: c, Linha: 8)
      CHARCONST (Valor: 'z', Linha: 8)
    ASSIGN (Linha: 10)
      ID (Nome: resultado, Linha: 10)
      FUNCCALL (Linha: 10)
        ID (Nome: soma, Linha: 10)
        ARGS:
          INTCONST (Valor: 5, Linha: 10)
          ID (Nome: c, Linha: 10)
    WRITE (Linha: 12)
      ID (Nome: resultado, Linha: 12)
    NOVALINHA (Linha: 13)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 8
    move $fp, $sp


soma:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    sw $a1, -8($fp)
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 122
    sw $t0, -4($fp)
    li $t1, 5
    move $a0, $t1
    lw $t1, -4($fp)
    move $a1, $t1
    jal soma
    move $t0, $v0
    sw $t0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 8
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./semantico/Errados/FibEfatVersao2ErroAtribuicaoVarDeTipoDiferenteDaExpressaoLin22.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável somaFunc redeclarada na linha 27
ERRO: Variável n redeclarada na linha 29
ERRO SEMÂNTICO: Tipos incompatíveis na atribuição da linha 22. Não é possível atribuir um valor do tipo 'int' a uma variável do tipo 'char'.
ERRO SEMÂNTICO: Tipos incompatíveis na atribuição da linha 48. Não é possível atribuir um valor do tipo 'int' a uma variável do tipo 'char'.
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -8($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    sw $t0, -4($fp)
    lw $t0, -4($fp)
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./semantico/Errados/FuncSomaErroNumParamDeChamaaDifNumParamFormal.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO SEMÂNTICO: Número incorreto de argumentos para a função 'soma'. Esperava 2, mas recebeu 1 (linha 10).
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: soma, Tipo Retorno: int, Linha: 3)
  PARAMS:
    VAR_DECL (Nome: a, Tipo: int, Linha: 1)
    VAR_DECL (Nome: b, Tipo: int, Linha: 1)
  CORPO:
    BLOCK (Linha: 3)
      COMANDOS:
        RETURN (Linha: 2)
          OP_BIN (Op: 0, Linha: 2)
            ID (Nome: a, Linha: 2)
            ID (Nome: b, Linha: 2)
BLOCK (Linha: 14)
  DECLARAÇÕES:
    VAR_DECL (Nome: resultado, Tipo: int, Linha: 8)
    VAR_DECL (Nome: x, Tipo: int, Linha: 8)
  COMANDOS:
    ASSIGN (Linha: 8)
      ID (Nome: x, Linha: 8)
      INTCONST (Valor: 4, Linha: 8)
    ASSIGN (Linha: 10)
      ID (Nome: resultado, Linha: 10)
      FUNCCALL (Linha: 10)
        ID (Nome: soma, Linha: 10)
        ARGS:
          ID (Nome: x, Linha: 10)
    WRITE (Linha: 12)
      ID (Nome: resultado, Linha: 12)
    NOVALINHA (Linha: 13)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 8
    move $fp, $sp


soma:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    sw $a1, -8($fp)
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 4
    sw $t0, -4($fp)
    lw $t1, -4($fp)
    move $a0, $t1
    jal soma
    move $t0, $v0
    sw $t0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 8
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/SeqOrdenada.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável quant redeclarada na linha 31
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str4: .asciiz ""DESORDENADA""
_str3: .asciiz ""ORDENADA""
_str2: .asciiz ""digite o tamanho de uma sequencia de numeros inteiros - digite 0 para terminar.""
_str1: .asciiz "" numeros inteiros separados entre si por um espaco""
_str0: .asciiz ""digite uma sequencia de ""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


checaOrd:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    li $t0, 118
    sw $t0, -4($fp)
    li $t0, 1
    sw $t0, -4($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_0:
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_1

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    lw $t1, -4($fp)
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    lw $t0, -4($fp)
    sw $t0, -4($fp)
    j _L_endif_3
_L_else_2:
    li $t1, 102
    sw $t1, -4($fp)
    lw $t1, -4($fp)
    sw $t1, -4($fp)
_L_endif_3:
    lw $t1, -4($fp)
    li $t2, 1
    add $t1, $t1, $t2
    sw $t1, -4($fp)
    lw $t2, -4($fp)
    lw $t3, -4($fp)
    slt $t2, $t2, $t3
    beq $t2, $zero, _L_else_4
    lw $t2, -4($fp)
    sw $t2, -4($fp)
    j _L_endif_5
_L_else_4:
    li $t3, 102
    sw $t3, -4($fp)
    lw $t3, -4($fp)
    sw $t3, -4($fp)
_L_endif_5:
    lw $t3, -4($fp)
    li $t4, 1
    add $t3, $t3, $t4
    sw $t3, -4($fp)
    lw $t4, -4($fp)
    li $t5, 1
    add $t4, $t4, $t5
    sw $t4, -4($fp)
    j _L_startwhile_0
_L_endwhile_1:
    lw $t4, -4($fp)
    move $v0, $t4
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $v0, 4
    syscall
    lw $t4, -4($fp)

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_6:
    lw $t4, -4($fp)
    lw $t5, -4($fp)
    slt $t4, $t4, $t5
    beq $t4, $zero, _L_endwhile_7

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t4, -4($fp)
    lw $t5, -4($fp)
    slt $t4, $t4, $t5
    beq $t4, $zero, _L_else_8
    lw $t4, -4($fp)
    sw $t4, -4($fp)
    j _L_endif_9
_L_else_8:
    li $t5, 102
    sw $t5, -4($fp)
    lw $t5, -4($fp)
    sw $t5, -4($fp)
_L_endif_9:
    lw $t5, -4($fp)
    li $t6, 1
    add $t5, $t5, $t6
    sw $t5, -4($fp)
    lw $t6, -4($fp)
    lw $t7, -4($fp)
    slt $t6, $t6, $t7
    beq $t6, $zero, _L_else_10
    lw $t6, -4($fp)
    sw $t6, -4($fp)
    j _L_endif_11
_L_else_10:
    li $t7, 102
    sw $t7, -4($fp)
    lw $t7, -4($fp)
    sw $t7, -4($fp)
_L_endif_11:
    lw $t7, -4($fp)
    li $t8, 1
    add $t7, $t7, $t8
    sw $t7, -4($fp)
    lw $t8, -4($fp)
    li $t9, 1
    add $t8, $t8, $t9
    sw $t8, -4($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t8, -4($fp)
    move $v0, $t8
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $t8, -4($fp)

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall
    li $v0, 4
    syscall
_L_startwhile_12:
    lw $t8, -4($fp)
    lw $t9, -4($fp)
    slt $t8, $t8, $t9
    beq $t8, $zero, _L_endwhile_13

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t8, -4($fp)
    lw $t9, -4($fp)
    slt $t8, $t8, $t9
    beq $t8, $zero, _L_else_14
    lw $t8, -4($fp)
    sw $t8, -4($fp)
    j _L_endif_15
_L_else_14:
    li $t9, 102
    sw $t9, -4($fp)
    lw $t9, -4($fp)
    sw $t9, -4($fp)
_L_endif_15:
    lw $t9, -4($fp)


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/FibEfatCorretoVersao2.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável somaFunc redeclarada na linha 27
ERRO: Variável n redeclarada na linha 29
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    sw $t0, -4($fp)
    lw $t0, -4($fp)
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/expressao1Correto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
BLOCK (Linha: 8)
  DECLARAÇÕES:
    VAR_DECL (Nome: x, Tipo: int, Linha: 4)
    VAR_DECL (Nome: y, Tipo: int, Linha: 3)
    VAR_DECL (Nome: z, Tipo: int, Linha: 3)
    VAR_DECL (Nome: v, Tipo: int, Linha: 3)
  COMANDOS:
    ASSIGN (Linha: 4)
      ID (Nome: z, Linha: 4)
      ASSIGN (Linha: 4)
        ID (Nome: y, Linha: 4)
        ASSIGN (Linha: 4)
          ID (Nome: x, Linha: 4)
          INTCONST (Valor: 50, Linha: 4)
    WRITE (Linha: 5)
      ID (Nome: x, Linha: 5)
    STRINGCONST (Valor: "" "", Linha: 5)
    WRITE (Linha: 5)
      ID (Nome: y, Linha: 5)
    STRINGCONST (Valor: "" "", Linha: 5)
    WRITE (Linha: 5)
      ID (Nome: z, Linha: 5)
    NOVALINHA (Linha: 6)
    WRITE (Linha: 7)
      OP_BIN (Op: 1, Linha: 7)
        OP_BIN (Op: 2, Linha: 7)
          ID (Nome: x, Linha: 7)
          INTCONST (Valor: 2, Linha: 7)
        OP_BIN (Op: 3, Linha: 7)
          ID (Nome: y, Linha: 7)
          INTCONST (Valor: 4, Linha: 7)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str0: .asciiz "" ""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 4
    move $fp, $sp

    li $t0, 50
    sw $t0, -4($fp)
    sw $t0, -4($fp)
    sw $t0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    lw $t0, -4($fp)
    li $t1, 2
    mul $t0, $t0, $t1
    lw $t1, -4($fp)
    li $t2, 4
    div $t1, $t2
    mflo $t1
    sub $t0, $t0, $t1

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 4
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/FibEfatCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 30
WARN: Nenhum registrador temporário livre! Contornando com workaround
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str5: .asciiz ""A subtracao do valor do fatorial pelo valor de finbonacci e: ""
_str4: .asciiz ""A soma do valor do fatorial com o valor de fibonacci e: ""
_str3: .asciiz ""Fibonacci de ""
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra

fibonacci:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 1
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_5
_L_else_4:
    lw $t1, -4($fp)
    li $t2, 1
    sub $t1, $t1, $t2
    move $a0, $t1
    jal fibonacci
    move $t0, $v0
    lw $t2, -4($fp)
    li $t3, 2
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    add $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_5:
_L_endif_3:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    li $t1, 0
    sub $t0, $t0, $t1
    sw $t0, -4($fp)
_L_startwhile_6:
    lw $t0, -4($fp)
    li $t1, 0
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_7
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_6
_L_endwhile_7:
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0
    sw $t0, fat
    lw $t2, -4($fp)
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    sw $t1, fat
    li $v0, 4
    syscall
    lw $t1, -4($fp)

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, fat

    # Escreve um inteiro
    move $a0, $t1
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t2, -4($fp)
    move $a0, $t2
    jal fibonacci
    move $t1, $v0
    sw $t1, fib
    lw $t2, -4($fp)

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t2, fat

    # Escreve um inteiro
    move $a0, $t2
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t3, -4($fp)
    move $a0, $t3
    jal fibonacci
    move $t2, $v0
    sw $t2, fib
    li $v0, 4
    syscall
    lw $t3, fat

    # Escreve um inteiro
    move $a0, $t3
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t4, -4($fp)
    move $a0, $t4
    jal fibonacci
    move $t3, $v0
    sw $t3, fib
    lw $t4, fat

    # Escreve um inteiro
    move $a0, $t4
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t5, -4($fp)
    move $a0, $t5
    jal fibonacci
    move $t4, $v0
    sw $t4, fib

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t6, -4($fp)
    move $a0, $t6
    jal fibonacci
    move $t5, $v0
    sw $t5, fib
    lw $t7, -4($fp)
    move $a0, $t7
    jal fibonacci
    move $t6, $v0
    sw $t6, fib
    li $v0, 4
    syscall
    lw $t6, -4($fp)

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t6, fib

    # Escreve um inteiro
    move $a0, $t6
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t6, fat
    lw $t7, fib
    add $t6, $t6, $t7
    sw $t6, somaFunc
    lw $t7, -4($fp)

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t7, fib

    # Escreve um inteiro
    move $a0, $t7
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t7, fat
    lw $t8, fib
    add $t7, $t7, $t8
    sw $t7, somaFunc
    li $v0, 4
    syscall
    lw $t8, fib

    # Escreve um inteiro
    move $a0, $t8
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t8, fat
    lw $t9, fib
    add $t8, $t8, $t9
    sw $t8, somaFunc
    lw $t9, fib

    # Escreve um inteiro
    move $a0, $t9
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t9, fat


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/variaveisGlobaisVariaveisFuncoesCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável x redeclarada na linha 8
ERRO: Variável x redeclarada na linha 10
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
VAR_DECL (Nome: x, Tipo: int, Linha: 8)
FUNC_DEF (Nome: duplicado, Tipo Retorno: int, Linha: 6)
  PARAMS:
    VAR_DECL (Nome: x, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 6)
      COMANDOS:
        WRITE (Linha: 4)
          ID (Nome: x, Linha: 4)
        RETURN (Linha: 5)
          INTCONST (Valor: 0, Linha: 5)
BLOCK (Linha: 12)
  DECLARAÇÕES:
    VAR_DECL (Nome: x, Tipo: int, Linha: 10)
  COMANDOS:
    ASSIGN (Linha: 10)
      ID (Nome: x, Linha: 10)
      INTCONST (Valor: 2, Linha: 10)
    FUNCCALL (Linha: 11)
      ID (Nome: duplicado, Linha: 11)
      ARGS:
        ID (Nome: x, Linha: 11)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
x: .word 0

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


duplicado:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 0
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 2
    sw $t0, -4($fp)
    lw $t1, -4($fp)
    move $a0, $t1
    jal duplicado
    move $t0, $v0

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/NotaEmConceito.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável conceito redeclarada na linha 11
ERRO: Variável conceito redeclarada na linha 20
ERRO: Variável conceito redeclarada na linha 29
ERRO: Variável conceito redeclarada na linha 36
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
BLOCK (Linha: 44)
  DECLARAÇÕES:
    VAR_DECL (Nome: nota, Tipo: int, Linha: 4)
    VAR_DECL (Nome: conceito, Tipo: car, Linha: 4)
  COMANDOS:
    STRINGCONST (Valor: ""Digite um valor inteiro para a nota de um aluno"", Linha: 4)
    NOVALINHA (Linha: 5)
    READ (Linha: 6)
      ID (Nome: nota, Linha: 6)
    IF (Linha: 42)
      OP_BIN (Op: 6, Linha: 8)
        ID (Nome: nota, Linha: 8)
        INTCONST (Valor: 6, Linha: 8)
      BLOCK (Linha: 15)
        DECLARAÇÕES:
          VAR_DECL (Nome: conceito, Tipo: car, Linha: 11)
        COMANDOS:
          ASSIGN (Linha: 11)
            ID (Nome: conceito, Linha: 11)
            CHARCONST (Valor: 'D', Linha: 11)
          STRINGCONST (Valor: ""Conceito: "", Linha: 12)
          WRITE (Linha: 13)
            ID (Nome: conceito, Linha: 13)
          NOVALINHA (Linha: 14)
    ELSE
      BLOCK (Linha: 42)
        COMANDOS:
          IF (Linha: 41)
            OP_BIN (Op: 6, Linha: 17)
              ID (Nome: nota, Linha: 17)
              INTCONST (Valor: 7, Linha: 17)
            BLOCK (Linha: 24)
              DECLARAÇÕES:
                VAR_DECL (Nome: conceito, Tipo: car, Linha: 20)
              COMANDOS:
                ASSIGN (Linha: 20)
                  ID (Nome: conceito, Linha: 20)
                  CHARCONST (Valor: 'C', Linha: 20)
                STRINGCONST (Valor: ""Conceito: "", Linha: 21)
                WRITE (Linha: 22)
                  ID (Nome: conceito, Linha: 22)
                NOVALINHA (Linha: 23)
          ELSE
            BLOCK (Linha: 41)
              COMANDOS:
                IF (Linha: 40)
                  OP_BIN (Op: 6, Linha: 26)
                    ID (Nome: nota, Linha: 26)
                    INTCONST (Valor: 9, Linha: 26)
                  BLOCK (Linha: 33)
                    DECLARAÇÕES:
                      VAR_DECL (Nome: conceito, Tipo: car, Linha: 29)
                    COMANDOS:
                      ASSIGN (Linha: 29)
                        ID (Nome: conceito, Linha: 29)
                        CHARCONST (Valor: 'B', Linha: 29)
                      STRINGCONST (Valor: ""Conceito: "", Linha: 30)
                      WRITE (Linha: 31)
                        ID (Nome: conceito, Linha: 31)
                      NOVALINHA (Linha: 32)
                ELSE
                  BLOCK (Linha: 40)
                    DECLARAÇÕES:
                      VAR_DECL (Nome: conceito, Tipo: car, Linha: 36)
                    COMANDOS:
                      ASSIGN (Linha: 36)
                        ID (Nome: conceito, Linha: 36)
                        CHARCONST (Valor: 'A', Linha: 36)
                      STRINGCONST (Valor: ""Conceito: "", Linha: 37)
                      WRITE (Linha: 38)
                        ID (Nome: conceito, Linha: 38)
                      NOVALINHA (Linha: 39)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str1: .asciiz ""Conceito: ""
_str0: .asciiz ""Digite um valor inteiro para a nota de um aluno""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 8
    move $fp, $sp

    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_2
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_3
_L_else_2:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_4
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_5
_L_else_4:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_5:
_L_endif_3:
_L_endif_1:

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_6
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_7
_L_else_6:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_8
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_9
_L_else_8:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_10
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_11
_L_else_10:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_11:
_L_endif_9:
_L_endif_7:

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_12
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_13
_L_else_12:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_14
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_15
_L_else_14:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_16
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_17
_L_else_16:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_17:
_L_endif_15:
_L_endif_13:
    lw $t0, -4($fp)
    li $t1, 6
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_18
    li $t0, 68
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_19
_L_else_18:
    lw $t0, -4($fp)
    li $t1, 7
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_20
    li $t0, 67
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_21
_L_else_20:
    lw $t0, -4($fp)
    li $t1, 9
    slt $t0, $t0, $t1
    beq $t0, $zero, _L_else_22
    li $t0, 66
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    j _L_endif_23
_L_else_22:
    li $t0, 65
    sw $t0, -4($fp)
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um caractere
    move $a0, $t0
    li $v0, 11
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
_L_endif_23:
_L_endif_21:
_L_endif_19:

    # Limpeza do Stack Frame
    addu $sp, $sp, 8
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Corretos/fatorialCorreto.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 12
Análise léxico-sintática concluída com sucesso.

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
FUNC_DEF (Nome: fatorial, Tipo Retorno: int, Linha: 8)
  PARAMS:
    VAR_DECL (Nome: n, Tipo: int, Linha: 2)
  CORPO:
    BLOCK (Linha: 8)
      COMANDOS:
        IF (Linha: 7)
          OP_BIN (Op: 4, Linha: 3)
            ID (Nome: n, Linha: 3)
            INTCONST (Valor: 0, Linha: 3)
          RETURN (Linha: 5)
            INTCONST (Valor: 1, Linha: 5)
        ELSE
          RETURN (Linha: 7)
            OP_BIN (Op: 2, Linha: 7)
              ID (Nome: n, Linha: 7)
              FUNCCALL (Linha: 7)
                ID (Nome: fatorial, Linha: 7)
                ARGS:
                  OP_BIN (Op: 1, Linha: 7)
                    ID (Nome: n, Linha: 7)
                    INTCONST (Valor: 1, Linha: 7)
BLOCK (Linha: 23)
  DECLARAÇÕES:
    VAR_DECL (Nome: n, Tipo: int, Linha: 12)
  COMANDOS:
    ASSIGN (Linha: 12)
      ID (Nome: n, Linha: 12)
      INTCONST (Valor: 1, Linha: 12)
    WHILE (Linha: 17)
      OP_BIN (Op: 8, Linha: 13)
        ID (Nome: n, Linha: 13)
        INTCONST (Valor: 0, Linha: 13)
      BLOCK (Linha: 17)
        COMANDOS:
          STRINGCONST (Valor: ""digite um numero"", Linha: 14)
          NOVALINHA (Linha: 15)
          READ (Linha: 16)
            ID (Nome: n, Linha: 16)
    STRINGCONST (Valor: ""O fatorial de "", Linha: 18)
    WRITE (Linha: 19)
      ID (Nome: n, Linha: 19)
    STRINGCONST (Valor: "" e: "", Linha: 20)
    WRITE (Linha: 21)
      FUNCCALL (Linha: 21)
        ID (Nome: fatorial, Linha: 21)
        ARGS:
          ID (Nome: n, Linha: 21)
    NOVALINHA (Linha: 22)
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"
_str2: .asciiz "" e: ""
_str1: .asciiz ""O fatorial de ""
_str0: .asciiz ""digite um numero""

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


fatorial:
    subu $sp, $sp, 32
    sw $ra, 20($sp)
    sw $fp, 16($sp)
    addu $fp, $sp, 32
    sw $a0, -4($fp)
    lw $t0, -4($fp)
    li $t1, 0
    seq $t0, $t0, $t1
    beq $t0, $zero, _L_else_0
    li $t0, 1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    j _L_endif_1
_L_else_0:
    lw $t0, -4($fp)
    lw $t2, -4($fp)
    li $t3, 1
    sub $t2, $t2, $t3
    move $a0, $t2
    jal fatorial
    move $t1, $v0
    mul $t0, $t0, $t1
    move $v0, $t0
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
_L_endif_1:
    lw $ra, 20($sp)
    lw $fp, 16($sp)
    addu $sp, $sp, 32
    jr $ra
    li $t0, 1
    sw $t0, -4($fp)
_L_startwhile_2:
    lw $t0, -4($fp)
    li $t1, 0
    sgt $t0, $t0, $t1
    beq $t0, $zero, _L_endwhile_3
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)

    # Leitura de Inteiro
    li $v0, 5
    syscall
    sw $v0, 0($fp)
    j _L_startwhile_2
_L_endwhile_3:
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t0, -4($fp)

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall
    lw $t1, -4($fp)
    move $a0, $t1
    jal fatorial
    move $t0, $v0

    # Escreve um inteiro
    move $a0, $t0
    li $v0, 1
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Imprime uma nova linha
    la $a0, _nl
    li $v0, 4
    syscall

    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/expressao1ErroLin4CadeiaNaoTermina.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: CARACTERE INVÁLIDO 4
ERRO SINTÁTICO: syntax error na linha 4
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 16
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 16
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/expressao1ErroLin4PontoVirg.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO SINTÁTICO: syntax error na linha 4
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 16
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 16
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/fatorialErroLin15String2linhas.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 12
ERRO: CARACTERE INVÁLIDO 14
ERRO SINTÁTICO: syntax error na linha 14
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/FibEfatErroBlocoEnquantoNaoTerminaLin30.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 26
ERRO SINTÁTICO: syntax error na linha 51
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 12
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 12
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/erroLin6Caractereinvalido.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: CARACTERE INVÁLIDO 6
ERRO SINTÁTICO: syntax error na linha 6
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 16
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 16
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/string_multilinha_erro.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: CARACTERE INVÁLIDO 2
ERRO SINTÁTICO: syntax error na linha 2
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/fatorialErroEntquantoSemExecuteLinha13.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável n redeclarada na linha 12
ERRO SINTÁTICO: syntax error na linha 13
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/erroLin6AsteriscoAmais.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO SINTÁTICO: syntax error na linha 6
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 16
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 16
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/NotaEmConceitoErroSenaoSemSeLin25.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: Variável conceito redeclarada na linha 11
ERRO SINTÁTICO: syntax error na linha 25
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 8
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 8
    li $v0, 10
    syscall


############################################################
ARQUIVO FONTE: ./sintatico/Errados/sintatico_fatorialErroLin1Comentario.g
############################################################

--- SAÍDA DO COMPILADOR (AST & LOGS) ---
ERRO: COMENTÁRIO NAO TERMINA 27
ERRO SINTÁTICO: syntax error na linha 27
Falha na análise lexico-sintática, relatório a seguir:

--- INICIANDO ANÁLISE SEMÂNTICA ---
--- FIM DA ANÁLISE SEMÂNTICA ---
Código MIPS gerado com sucesso em output.asm
--- INÍCIO DA ÁRVORE SINTÁTICA ABSTRATA ---
--- FIM DA ÁRVORE SINTÁTICA ABSTRATA ---

--- CÓDIGO ASSEMBLY MIPS GERADO ---
.data
_nl: .asciiz "\n"

.text
.globl main

main:

    # Setup do Stack Frame para main
    subu $sp, $sp, 0
    move $fp, $sp


    # Limpeza do Stack Frame
    addu $sp, $sp, 0
    li $v0, 10
    syscall


